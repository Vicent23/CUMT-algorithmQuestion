/*
现在我们定义一种非常简单的密码，它的长度固定为n（n<=30）并且每一位只能由数字0或者数字1组成，但是有一个特殊的要求：一个密码序列中至少要有连续的3个0出现才可以，否则就是无效的。现在给定你密码序列的长度n，你的任务是计算长度为n的序列能产生多少种不同的并且有效的密码？
输入
输入包含多组数据，每组数据只有一个正整数n（1<=n<=30）代表密码序列的长度，单独占一行。
输出
对每组数据，输出一个整数，代表长度为n的序列能产生的不同密码的种类数。
样例输入
4
5
6
样例输出
3
8
20
正常情况下，每一次在后面增加一位，都有0和1两种可能，故有 dp[n] = 2 * dp[n-1]。
特殊情况下，当前面是100，新增的一位为1时，前n-4位满足条件的有2^(n-4)个，故加上2^（n-4）比dp[n-4]多出来的部分。
即 dp[n] + = (1 << (n-4)) - dp[n-4]

*/
#include <iostream>
using namespace std;
int main()
{
    int n, dp[31] = {0, 0, 0, 1};  // 只有 3位的时候才有 第一个合规的密码序列
    for (int i = 4; i < 31; i++)
    {
        dp[i] = 2 * dp[i - 1] + (1 << (i - 4)) - dp[i - 4];    //找递推规律  1<<(i-4) 即 i ^ (i-4)
    }   
    while (cin >> n)
    {
        cout << dp[n] << endl;
    }
    return 0;
}
