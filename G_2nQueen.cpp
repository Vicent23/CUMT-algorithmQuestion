/*
给定一个 n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入 n 个黑皇后和 n个白皇后，
使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于 8。
输入
输入的第一行为一个整数 n，表示棋盘的大小。
接下来 n 行，每行 n 个 0 或 1 的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为 0，表示对应的位置不可以放皇后。
输出
输出一个整数，表示总共有多少种放法
样例输入
4
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1

样例输出
2
*/
#include <iostream>
#include <cmath>
using namespace std;
int n, map[8][8], ans; //定义n为棋盘大小n*n矩阵，定义数组二维map来储存是否可以放黑白皇后，1为可以，0反之
int bq[8], wq[8];      //定义bq，wq分别用于存储 在每一行都在哪一个位置摆放了黑（black queen）。白皇后 (write queen)

int WQ(int k) //摆放白皇后
{
    if (k == n)
    {          // n个白皇后摆放好
        ans++; //结果 +1
    }
    int i, j;
    for (i = 0; i < n; i++)
    {
        if (map[k][i] == 0)  //不能放
            continue;
        if (bq[k] == i)
            continue; //测试是否黑皇后摆放的位置
        for (j = 0; j < k; j++)
        {
            if (wq[j] == i || abs(wq[j] - i) == abs(k - j))
                break;
        }

        if (j == k)
        {
            wq[k] = i;
            WQ(k + 1);
        }
    }
}

int BQ(int k) //摆放黑皇后函数
{
    if (k == n) // n个黑皇后已经摆放好
    { //开始摆放白皇后
        WQ(0);  //赋初值均为0，即从第一行开始摆放
    }
    int i, j;
    for (i = 0; i < n; i++) // k行i列，开始逐个尝试摆放皇后（k的变化是通过递归实现的，i的变化是通过for循环实现的。）
    {
        if (map[k][i] == 0)
            continue;           //若map对应的位置为0,即不能放置皇后 ，跳过这次循环
        for (j = 0; j < k; j++) //将现在摆放的位置与已经摆好的皇后进行依次比较，看是否有冲突
        {
            if (bq[j] == i || abs(bq[j] - i) == abs(k - j))  //bq[j]=i 表示第j行 第i列放了皇后， 列与列的差值等于行与行的差值说明对角线上有
                break;
            // bq[j]==i,列数是否冲突； abs(bq[j]-i) == k-j，是不是对角线。
        }
        if (j == k) //如果和前面摆放的所有皇后不冲突，就将第k行摆放位置记录bq[k]
        {
            bq[k] = i; //第k行第 j 列 防置皇后
            BQ(k + 1); //递归k+1
        }
    }
}

int main()
{
    ans = 0;                    //计数器赋初值为0，每摆放成功一次，计数器加1
    cin >> n;                   //输入变量n为棋盘  n*n
    for (int i = 0; i < n; i++) //依次输入 0 1值，即对应位置能不能摆放皇后
    {
        for (int j = 0; j < n; j++)
        {
            cin >> map[i][j];
        }
    }
    BQ(0);               //执行摆放黑皇后函数（当然先摆放白皇后也ok，一个道理）
    cout << ans << endl; //输出可摆放的方法数。
    return 0;
}
